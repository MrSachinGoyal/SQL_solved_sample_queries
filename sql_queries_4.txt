CREATE DATABASE demo_db2;

USE demo_db2;

# Question-61:
Advertiser, daily_pay table

CREATE TABLE advertiser (
  user_id VARCHAR(255),
  status VARCHAR(20)
);

CREATE TABLE daily_pay (
  user_id VARCHAR(255),
  paid DECIMAL(10, 2)
);

INSERT INTO advertiser (user_id, status)
VALUES
  ('bing', 'NEW'),
  ('yahoo', 'NEW'),
  ('alibaba', 'EXISTING');
  
INSERT INTO daily_pay (user_id, paid)
VALUES
  ('yahoo', 45.00),
  ('alibaba', 100.00),
  ('target', 13.00);

Q61. Write a query to update the Facebook advertiser's status using the daily_pay table. Advertiser is a two-column table containing the user id and their payment status based on the        last payment and daily_pay table has current information about their payment. Only advertisers who paid will show up in this table. Output the user id and current payment status        sorted by the user id.

SELECT user_id, 
CASE 
    WHEN user_id IN (SELECT DISTINCT(user_id) FROM daily_pay) THEN 'Existing'
	  ELSE 'Churn'
END AS current_status
FROM advertiser;

# Question-62:
Server_utilization table

CREATE TABLE server_utilization (
  server_id INTEGER,
  status_time TIMESTAMP,
  session_status VARCHAR(255)
);

INSERT INTO server_utilization (server_id, status_time, session_status)
VALUES
  (1, '2022-08-02 10:00:00', 'start'),
  (1, '2022-08-04 10:00:00', 'stop'),
  (2, '2022-08-17 10:00:00', 'start'),
  (2, '2022-08-24 10:00:00', 'stop');


Q62. Amazon Web Services (AWS) is powered by fleets of servers. Senior management has requested data-driven solutions to optimise server usage.
     Write a query that calculates the total time that the fleet of servers was running. The output should be in units of full days

WITH server_data AS (SELECT server_id, status_time AS server_start_time, 
          					 LEAD(status_time, 1) OVER(PARTITION BY server_id ORDER BY status_time ASC) as server_stop_time
                     FROM server_utilization)

SELECT 
SUM(ROUND((HOUR(TIMEDIFF(server_stop_time, server_start_time)))/24)) AS total_uptime
FROM server_data
WHERE server_stop_time IS NOT NULL;
  
# Question-63: 
Merchant_transactions table

CREATE TABLE merchant_transactions (
  transaction_id INTEGER,
  merchant_id INTEGER,
  credit_card_id INTEGER,
  amount INTEGER,
  transaction_timestamp DATETIME
);

INSERT INTO merchant_transactions (transaction_id, merchant_id, credit_card_id, amount, transaction_timestamp)
VALUES
  (1, 101, 1, 100, '2022-09-25 12:00:00'),
  (2, 101, 1, 100, '2022-09-25 12:08:00'),
  (3, 101, 1, 100, '2022-09-25 12:28:00'),
  (4, 102, 2, 300, '2022-09-25 12:00:00'),
  (6, 102, 2, 400, '2022-09-25 14:00:00');

Q63. Sometimes, payment transactions are repeated by accident; it could be due to user error, API failure or a retry error that causes a credit card to be charged twice. Using the           transactions table, identify any payments made at the same merchant with the same credit card for the same amount within 10 minutes of each other. Count such repeated payments.

WITH transaction_record AS (SELECT transaction_id, 
                                   merchant_id, 
                                   credit_card_id,
              							MINUTE(transaction_timestamp - (LEAD(transaction_timestamp,1) 
                            OVER(PARTITION BY merchant_id, credit_card_id ORDER BY transaction_timestamp ASC))) AS time_diff_between_two_transactions 
                            FROM merchant_transactions)

SELECT COUNT(*) AS payment_count
FROM transaction_record
WHERE time_diff_between_two_transactions > 0  AND time_diff_between_two_transactions <= 10;

# Question-64:
Orders5, Customers_data, Trips table

CREATE TABLE orders5 (
  order_id INTEGER,
  customer_id INTEGER,
  trip_id INTEGER,
  status ENUM('completed successfully', 'completed incorrectly', 'never received'),
  order_timestamp TIMESTAMP
);

INSERT INTO orders5 (order_id, customer_id, trip_id, status, order_timestamp)
VALUES
  (727424, 8472, 100463, 'completed successfully', '2022-06-05 09:12:00'),
  (242513, 2341, 100482, 'completed incorrectly', '2022-06-05 14:40:00'),
  (141367, 1314, 100362, 'completed incorrectly', '2022-06-07 15:03:00'),
  (582193, 5421, 100657, 'never received', '2022-07-07 15:22:00'),
  (253613, 1314, 100213, 'completed successfully', '2022-06-12 13:43:00');

CREATE TABLE trips (
  dasher_id INTEGER,
  trip_id INTEGER,
  estimated_delivery_timestamp TIMESTAMP,
  actual_delivery_timestamp TIMESTAMP
);

INSERT INTO trips (dasher_id, trip_id, estimated_delivery_timestamp, actual_delivery_timestamp)
VALUES
  (101, 100463, '2022-06-05 09:42:00', '2022-06-05 09:38:00'),
  (102, 100482, '2022-06-05 15:10:00', '2022-06-05 15:46:00'),
  (101, 100362, '2022-06-07 15:33:00', '2022-06-07 16:45:00'),
  (102, 100657, '2022-07-07 15:52:00', NULL),
  (103, 100213, '2022-06-12 14:13:00', '2022-06-12 14:10:00');

CREATE TABLE customers_data (
  customer_id INTEGER,
  signup_timestamp TIMESTAMP
);

INSERT INTO customers_data (customer_id, signup_timestamp)
VALUES
  (8472, '2022-05-30 00:00:00'),
  (2341, '2022-06-01 00:00:00'),
  (1314, '2022-06-03 00:00:00'),
  (1435, '2022-06-05 00:00:00'),
  (5421, '2022-06-07 00:00:00');

Q64. DoorDash's Growth Team is trying to make sure new users (those who are making orders in their first14 days) have a great experience on all their orders in their 2 weeks on the 
     platform. Unfortunately, many deliveries are being messed up because:
      ● the orders are being completed incorrectly (missing items, wrong order, etc.)
      ● the orders aren't being received (wrong address, wrong drop off spot)
      ● the orders are being delivered late (the actual delivery time is 30 minutes later than when the order was placed). 
     Note that the estimated_delivery_timestamp is automatically set to 30 minutes after the order_timestamp.
    
    Write a query to find the bad experience rate in the first 14 days for new users who signed up in June 2022. Output the percentage of bad experience rounded to 2 decimal places

WITH order_details AS (SELECT c.*, o.order_id, o.status,
					   ROUND(TIME_TO_SEC(TIMEDIFF(t.actual_delivery_timestamp, o.order_timestamp))/60) AS time_taken_for_delivery_in_mins
					   FROM customers_data c
					   INNER JOIN orders5 o
					   ON c.customer_id = o.customer_id
					   INNER JOIN trips t
					   ON o.trip_id = t.trip_id
					   WHERE MONTHNAME(signup_timestamp) = 'June' AND YEAR(signup_timestamp) = 2022
					   AND DATEDIFF(o.order_timestamp, c.signup_timestamp) <= 14)

SELECT 
ROUND((SUM(CASE 
               WHEN status in ('completed incorrectly', 'never received') OR time_taken_for_delivery_in_mins > 30 THEN 1
	           ELSE 0
           END)/COUNT(*))*100,2
     ) AS bad_experience_pct
FROM order_details o;

# Question-65: 
Salary, Employee5 table

CREATE TABLE Salary (
    id INT PRIMARY KEY,
    employee_id INT,
    amount INT,
    pay_date DATE
);

CREATE TABLE Employee5 (
    employee_id INT PRIMARY KEY,
    department_id INT
);

INSERT INTO Salary (id, employee_id, amount, pay_date)
VALUES
    (1, 1, 9000, '2017-03-31'),
    (2, 2, 6000, '2017-03-31'),
    (3, 3, 10000, '2017-03-31'),
    (4, 1, 7000, '2017-02-28'),
    (5, 2, 6000, '2017-02-28'),
    (6, 3, 8000, '2017-02-28');

INSERT INTO Employee5 (employee_id, department_id)
VALUES
    (1, 1),
    (2, 2),
    (3, 2);

Q65. Write an SQL query to report the comparison result (higher/lower/same) of the average salary of employees in a department to the company's average salary.

WITH salary_details AS (SELECT s.employee_id, s.amount, s.pay_date, e.department_id
						FROM salary s
						INNER JOIN 
						employee5 e
						ON s.employee_id = e.employee_id)

SELECT distinct pay_date, department_id,
CASE WHEN monthly_dept_avg_salary = monthly_company_avg_salary THEN 'same'
     WHEN monthly_dept_avg_salary < monthly_company_avg_salary THEN 'lower'
     ELSE 'higher'
END AS comparison
FROM
	(SELECT pay_date, department_id, amount,
	AVG(amount) OVER(PARTITION BY pay_date, department_id) AS monthly_dept_avg_salary,
	AVG(amount) OVER(PARTITION by pay_date) AS monthly_company_avg_salary
	FROM salary_details) tmp
ORDER BY department_id ASC;

# Question-66:
Activity2 table

CREATE TABLE Activity2 (
    player_id INT,
    device_id INT,
    event_date DATE,
    games_played INT,
    PRIMARY KEY (player_id, event_date)
);

INSERT INTO Activity2 (player_id, device_id, event_date, games_played)
VALUES
    (1, 2, '2016-03-01', 5),
    (1, 2, '2016-03-02', 6),
    (2, 3, '2017-06-25', 1),
    (3, 1, '2016-03-01', 0),
    (3, 4, '2016-07-03', 5);

Q66.The install date of a player is the first login day of that player. We define day one retention of some date x to be the number of players whose install date is x and they logged       back in on the day right after x, divided by the number of players whose install date is x, rounded to 2 decimal places.
    Write an SQL query to report for each install date, the number of players that installed the game on that day, and the day one retention.

WITH login_data AS (SELECT player_id, event_date,
					LAG(event_date,1,0) OVER(PARTITION BY player_id) AS prev_login_date, 
					MIN(event_date) OVER(PARTITION BY player_id) AS installation_date
					FROM activity2)
   
SELECT tmp2.*, 
       ROUND(tmp1.players_login_next_day/tmp2.no_of_installs,2) AS one_day_retention
FROM
	(SELECT installation_date, 
		   SUM(IF((DATEDIFF(event_date, prev_login_date) = 1), 1,0)) AS players_login_next_day
	FROM login_data
	GROUP BY installation_date) tmp1
	INNER JOIN
	(SELECT installation_date, COUNT(DISTINCT(player_id)) AS no_of_installs
	FROM login_data
	GROUP BY installation_date) tmp2
ON tmp1.installation_date = tmp2.installation_date;

# Question-67:
Players, Matches table

CREATE TABLE Players (
    player_id INT PRIMARY KEY,
    group_id INT
);

CREATE TABLE Matches (
    match_id INT PRIMARY KEY,
    first_player INT,
    second_player INT,
    first_score INT,
    second_score INT
);

INSERT INTO Players (player_id, group_id)
VALUES
    (15, 1),
    (25, 1),
    (30, 1),
    (45, 1),
    (10, 2),
    (35, 2),
    (50, 2),
    (20, 3),
    (40, 3);

INSERT INTO Matches (match_id, first_player, second_player, first_score, second_score)
VALUES
    (1, 15, 45, 3, 0),
    (2, 30, 25, 1, 2),
    (3, 30, 15, 2, 0),
    (4, 40, 20, 5, 2),
    (5, 35, 50, 1, 1);

Q67. The winner in each group is the player who scored the maximum total points within the group. In the case of a tie, the lowest player_id wins.
     Write an SQL query to find the winner in each group.

WITH group_player_scores AS (
							(SELECT p.group_id, tmp.*
							FROM 
								(SELECT second_player AS player,  SUM(second_score) AS total_score
								FROM matches
								GROUP BY player) tmp
								INNER JOIN players p
								ON p.player_id = tmp.player)
							UNION
							(SELECT p.group_id, tmp.*
							FROM 
								(SELECT first_player,  SUM(first_score) AS total_score
								FROM matches
								GROUP BY first_player) tmp
								INNER JOIN 
								players p
								ON p.player_id = tmp.first_player)
                                )
                                
SELECT group_id, player
FROM 
	(SELECT group_id, player,
	ROW_NUMBER() OVER(PARTITION BY group_id) AS row_val
	FROM
		(SELECT group_id, player, SUM(total_score) AS player_score
		FROM group_player_scores
		GROUP BY group_id, player
		ORDER BY group_id ASC, player_score DESC, player ASC) t1) t2
WHERE row_val = 1;

# Question-68:
Student2, Exam table

CREATE TABLE Student2 (
  student_id int PRIMARY KEY,
  student_name varchar(255)
);

CREATE TABLE Exam (
  exam_id int,
  student_id int,
  score int,
  PRIMARY KEY (exam_id, student_id)
);

INSERT INTO Student2 (student_id, student_name)
VALUES
  (1, 'Daniel'),
  (2, 'Jade'),
  (3, 'Stella'),
  (4, 'Jonathan'),
  (5, 'Will');

INSERT INTO Exam (exam_id, student_id, score)
VALUES
  (10, 1, 70),
  (10, 2, 80),
  (10, 3, 90),
  (20, 1, 80),
  (30, 1, 70),
  (30, 3, 80),
  (30, 4, 90),
  (40, 1, 60),
  (40, 2, 70),
  (40, 4, 80);

Q68. A quiet student is the one who took at least one exam and did not score the high or the low score. Write an SQL query to report the students (student_id, student_name) being quiet      in all exams. Do not return the student who has never taken any exam. Return the result table ordered by student_id.

WITH topper_list AS (SELECT e.exam_id, e.score, s.*,
					RANK() OVER(PARTITION BY exam_id ORDER BY score DESC) AS rank_value
					FROM student2 s
					INNER JOIN exam e
					ON s.student_id = e.student_id) 
                        
SELECT student_id, student_name 
FROM student2
WHERE student_id NOT IN (SELECT DISTINCT(student_id) FROM topper_list
                         WHERE rank_value = 1 OR rank_value = 3)
	  AND student_id IN (SELECT DISTINCT(student_id) FROM exam);

# Question-69:
Songs_history,Songs_weekly table

CREATE TABLE songs_history (
    history_id INTEGER,
    user_id INTEGER,
    song_id INTEGER,
    song_plays INTEGER
);

CREATE TABLE songs_weekly (
    user_id INTEGER,
    song_id INTEGER,
    listen_time DATETIME
);

INSERT INTO songs_history (history_id, user_id, song_id, song_plays)
VALUES (10011, 777, 1238, 11),
       (12452, 695, 4520, 1);

INSERT INTO songs_weekly (user_id, song_id, listen_time)
VALUES (777, 1238, '2022-08-01 12:00:00'),
       (695, 4520, '2022-08-04 08:00:00'),
       (125, 9630, '2022-08-04 16:00:00'),
       (695, 9852, '2022-08-07 12:00:00');

Q69. Write a query to output the user id, song id, and cumulative count of song plays as of 4 August 2022 sorted in descending order.

WITH song_info AS ((SELECT user_id, song_id, COUNT(*) AS song_plays 
					FROM songs_weekly
					WHERE DATE(listen_time) < '2022-08-05'
					GROUP BY user_id, song_id)
					UNION ALL
					(SELECT user_id, song_id, song_plays FROM songs_history))

SELECT user_id, song_id, SUM(song_plays) AS cum_count
FROM song_info
GROUP BY user_id, song_id
ORDER BY cum_count DESC;

# Question-70:
Emails, texts table

CREATE TABLE emails (
    email_id INTEGER,
    user_id INTEGER,
    signup_date DATETIME
);

INSERT INTO emails (email_id, user_id, signup_date)
VALUES (125, 7771, '2022-06-14 00:00:00'),
       (236, 6950, '2022-07-01 00:00:00'),
       (433, 1052, '2022-07-09 00:00:00');

CREATE TABLE texts (
    text_id INTEGER,
    email_id INTEGER,
    signup_action VARCHAR(255)
);

INSERT INTO texts (text_id, email_id, signup_action)
VALUES (6878, 125, 'Confirmed'),
       (6920, 236, 'Not Confirmed'),
       (6994, 236, 'Confirmed');

Q70. New TikTok users sign up with their emails, so each signup requires a text confirmation to activate the new user's account.
     Write a query to find the confirmation rate of users who confirmed their signups with text messages. Round the result to 2 decimal places.

SELECT 
ROUND((SUM(CASE WHEN signup_action = 'Confirmed' THEN 1 ELSE 0 END)/COUNT(*)), 2) AS confirmation_rate
FROM emails e
LEFT JOIN texts t
ON e.email_id = t.email_id
WHERE signup_action IS NOT NULL;

# Question-71:
Tweets table

CREATE TABLE tweets (
    tweet_id INTEGER,
    user_id INTEGER,
    tweet_date TIMESTAMP
);

INSERT INTO tweets (tweet_id, user_id, tweet_date)
VALUES (214252, 111, '2022-06-01 12:00:00'),
       (739252, 111, '2022-06-01 12:00:00'),
       (846402, 111, '2022-06-02 12:00:00'),
       (241425, 254, '2022-06-02 12:00:00'),
       (137374, 111, '2022-06-04 12:00:00');

Q71. Calculate the 3-day rolling average of tweets published by each user for each date that a tweet was posted. Output the user id, tweet date, and rolling averages rounded to 2            decimal places.

SELECT DATE(tweet_date) AS tweet_date, user_id, 
ROUND(AVG(COUNT(tweet_id)) OVER(PARTITION BY user_id ORDER BY DATE(tweet_date) AS RANGE BETWEEN INTERVAL '3' DAY PRECEDING AND CURRENT ROW), 2) AS rolling_average
FROM tweets
GROUP BY tweet_date, user_id;

# Question-72: 
Activities2, age_breakdown table

CREATE TABLE activities2 (
    activity_id INTEGER,
    user_id INTEGER,
    activity_type VARCHAR(10),
    time_spent FLOAT,
    activity_date DATETIME
);

INSERT INTO activities2 (activity_id, user_id, activity_type, time_spent, activity_date)
VALUES (7274, 123, 'open', 4.50, '2022-06-22 12:00:00'),
       (2425, 123, 'send', 3.50, '2022-06-22 12:00:00'),
       (1413, 456, 'send', 5.67, '2022-06-23 12:00:00'),
       (1414, 789, 'chat', 11.00, '2022-06-25 12:00:00'),
       (2536, 456, 'open', 3.00, '2022-06-25 12:00:00');

CREATE TABLE age_breakdown (
    user_id INTEGER,
    age_bucket ENUM('21-25', '26-30', '31-35')
);

INSERT INTO age_breakdown (user_id, age_bucket)
VALUES (123, '31-35'),
       (456, '26-30'),
       (789, '21-25');

Q72. Assume you are given the tables below containing information on Snapchat users, their ages, and their time spent sending and opening snaps. Write a query to obtain a breakdown of       the time spent sending vs. opening snaps (as a percentage of total time spent on these activities) for each age group. Output the age bucket and percentage of sending and opening       snaps. Round the percentage to 2 decimal places.

SELECT age_bucket,
SUM(CASE WHEN activity_type = 'open' THEN ROUND((time_spent/total_time_spent)*100, 2) 
    END) AS open_pct,
SUM(CASE WHEN activity_type = 'send' THEN ROUND((time_spent/total_time_spent)*100, 2) 
    END) AS send_pct
FROM 
	(SELECT ab.age_bucket, a.user_id, a.activity_type, a.time_spent,
	SUM(time_spent) OVER(PARTITION BY age_bucket) AS total_time_spent
	FROM activities2 a
	INNER JOIN age_breakdown ab
	ON a.user_id = ab.user_id
	WHERE activity_type IN ('send', 'open')) tmp
GROUP BY age_bucket;

# Question-73:
Personal_profiles, Employee_company, Company_pages table

CREATE TABLE personal_profiles (
    profile_id INTEGER,
    name VARCHAR(255),
    followers INTEGER
);

INSERT INTO personal_profiles (profile_id, name, followers)
VALUES (1, 'Nick Singh', 92000),
       (2, 'Zach Wilson', 199000),
       (3, 'Daliana Liu', 171000),
       (4, 'Ravit Jain', 107000),
       (5, 'Vin Vashishta', 139000),
       (6, 'Susan Wojcicki', 39000);

CREATE TABLE employee_company (
    personal_profile_id INTEGER,
    company_id INTEGER
);

INSERT INTO employee_company (personal_profile_id, company_id)
VALUES (1, 4),
       (1, 9),
       (2, 2),
       (3, 1),
       (4, 3),
       (5, 6),
       (6, 5);

CREATE TABLE company_pages (
    company_id INTEGER,
    name VARCHAR(255),
    followers INTEGER
);

INSERT INTO company_pages (company_id, name, followers)
VALUES (1, 'The Data Science Podcast', 8000),
       (2, 'Airbnb', 700000),
       (3, 'The Ravit Show', 6000),
       (4, 'DataLemur', 200),
       (5, 'YouTube', 1600000),
       (6, 'DataScience.Vin', 4500),
       (9, 'Ace The Data Science Interview', 4479);

Q73. The LinkedIn Creator team is looking for power creators who use their personal profile as a company or influencer page. This means that if someone's Linkedin page has more              followers than all the companies they work for, we can safely assume that person is a Power Creator. Keep in mind that if a person works at multiple companies, we should take into      account the company with the most followers. 
     Write a query to return the IDs of these LinkedIn power creators in ascending order

SELECT power_creators_id
FROM
	(SELECT 
	CASE WHEN emp_followers > company_followers THEN profile_id END AS power_creators_id
	FROM 
		(SELECT profile_id, 
			   MAX(pp.followers) AS emp_followers, MAX(cp.followers) AS company_followers
		FROM employee_company ec
		INNER JOIN 
		company_pages cp
		ON ec.company_id = cp.company_id
		INNER JOIN 
		personal_profiles pp
		ON ec.personal_profile_id = pp.profile_id
		GROUP BY profile_id) tmp) tmp2
WHERE power_creators_id IS NOT NULL
ORDER BY power_creators_id;

# Question-74:
UserActivity table

CREATE TABLE UserActivity (
  username VARCHAR(255),
  activity VARCHAR(255),
  startDate DATE,
  endDate DATE
);

INSERT INTO UserActivity (username, activity, startDate, endDate)
VALUES
  ('Alice', 'Travel', '2020-02-12', '2020-02-20'),
  ('Alice', 'Dancing', '2020-02-21', '2020-02-23'),
  ('Alice', 'Travel', '2020-02-24', '2020-02-28'),
  ('Bob', 'Travel', '2020-02-11', '2020-02-18');

Q74. Write an SQL query to show the second most recent activity of each user. If the user only has one activity, return that one. A user cannot perform more than one activity at the
     same time. Return the result table in any order

SELECT username, activity, startDate, endDate
FROM
	(SELECT *,
	RANK() OVER(PARTITION BY username ORDER BY startDate DESC) AS activity_sequence,
	count(activity) over (partition by username) as num_of_activities_per_user
	FROM useractivity) tmp
WHERE (num_of_activities_per_user != 1 AND activity_sequence = 2) OR (num_of_activities_per_user = 1 AND activity_sequence = 1);

# Question-75:
Student table

CREATE TABLE student
(	id INT,
	name VARCHAR(255),
    marks INT
);

INSERT INTO student (id, name, marks)
VALUES 
	(1, 'Ashley', 81),
    (2, 'Samantha', 75),
    (4, 'Julia', 76),
    (3, 'Belvet', 84);


Q75. Query the Name of any student in STUDENTS who scored higher than 75 Marks. Order your output by the last three characters of each name. If two or more students both have names 		 ending in the same last three characters (i.e.: Bobby, Robby, etc.), secondary sort them by ascending ID

SELECT name FROM student
WHERE marks > 75
ORDER BY RIGHT(name, 3), id ASC;
		
# Question-76:
Employee table

create table if not exists Employee
(
    employee_id int,
    name VARCHAR(50),
    months int,
    salary int
);

insert into Employee 
	VALUES 
    (12228,'Rose',15,1968),
	(33645,'Angela',1,3443),
    (45692,'Frank',17,1608),
    (56118,'Patrick',7,1345),
    (59725,'Lisa',11,2330),
    (74197,'Kimberly',16,4372),
    (78454,'Bonnie',8,1771),
    (83565,'Michael',6,2017),
    (98607,'Todd',5,3396),
    (99989,'Joe',9,3573);

Q76. Write a query that prints a list of employee names (i.e.: the name attribute) for employees in Employee having a salary greater than $2000 per month who have been employees for 	 	 less than 10 months. Sort your result by ascending employee_id.

SELECT name AS employee_name
FROM employee
WHERE months < 10 AND salary > 2000
ORDER BY employee_id;

# Question-77: 
Triangles table

CREATE TABLE triangles
(	A INT,
	B INT,
    C INT
);

INSERT INTO triangles (A, B ,C)
VALUES (20, 20, 23), (20, 20, 20), (20, 21, 22), (13, 14, 30);

Q77. Write a query identifying the type of each record in the TRIANGLES table using its three side lengths. Output one of the following statements for each record in the table:
       ● Equilateral: It's a triangle with sides of equal length.
       ● Isosceles: It's a triangle with sides of equal length.
       ● Scalene: It's a triangle with sides of differing lengths.
       ● Not A Triangle: The given values of A, B, and C don't form a triangle.

SELECT 
CASE 
	 WHEN form_triangle_or_not = 'Yes' AND A = B AND B = C THEN 'Equilateral'
	 WHEN form_triangle_or_not = 'Yes' AND (A <> B AND B <> C) THEN 'Scalene'
     WHEN form_triangle_or_not = 'No' AND (A <> B <> C) THEN 'Not a Triangle'
     ELSE 'Isosceles'
END AS type_triangle
FROM
	(SELECT A, B, C, IF((A+B > C), 'Yes', 'No') AS form_triangle_or_not
	 FROM triangles) tmp;

# Question-78:
Employees Table

CREATE TABLE Employees
(	id INT,
	name VARCHAR(255),
    salary INT CHECK(SALARY > 1000 AND SALARY < 100000)
);

INSERT INTO Employees (id, name, salary)
VALUES(1, 'Kristeen', 1420), (2, 'Ashley', 2006), (3, 'Julia', 2210), (4, 'Maria', 3000);

Q78. Samantha was tasked with calculating the average monthly salaries for all employees in the EMPLOYEES table, but did not realise her keyboard's 0 key was broken until after 			 completing the calculation. She wants your help finding the difference between her miscalculation (using salaries with any zeros removed), and the actual average salary.
     Write a query calculating the amount of error (i.e.: actual - miscalculated average monthly salaries), and round it up to the next integer

SELECT ROUND((AVG(salary) -  AVG(REPLACE(salary, '0', '')))) AS difference FROM employees;

# Question-79:
Employee table

create table if not exists Employee
(
    employee_id int,
    name VARCHAR(50),
    months int,
    salary int
);

insert into Employee 
	VALUES 
    (12228,'Rose',15,1968),
	(33645,'Angela',1,3443),
    (45692,'Frank',17,1608),
    (56118,'Patrick',7,1345),
    (59725,'Lisa',11,2330),
    (74197,'Kimberly',16,4372),
    (78454,'Bonnie',8,1771),
    (83565,'Michael',6,2017),
    (98607,'Todd',5,3396),
    (99989,'Joe',9,3573);

Q79. We define an employee's total earnings to be their monthly salary * months worked, and the maximum total earnings to be the maximum total earnings for any employee in the Employee 	 table.
 	 Write a query to find the maximum total earnings for all employees as well as the total number of employees who have maximum total earnings. Then print these values as 2 space-		 separated integers.

SELECT total_earnings, COUNT(employee_id) AS emp_count_having_max_earnings
FROM
	(SELECT *, (months*salary) AS total_earnings,
	 RANK() OVER(ORDER BY (months*salary) DESC) AS rank_by_total_earnings
	 FROM employee) tmp
WHERE rank_by_total_earnings = 1
GROUP BY total_earnings;

# Questions-80 to Questions-81:
Occupations table

CREATE TABLE occupations
(	NAME VARCHAR(255),
	OCCUPATION VARCHAR(255)
);

INSERT INTO occupations (NAME, OCCUPATION)
VALUES ('Samantha', 'Doctor'),
	   ('Julia', 'Actor'),
       ('Maria', 'Actor'),
       ('Meera', 'Singer'),
       ('Ashley', 'Professor'),
       ('Ketty', 'Professor'),
       ('Christeen', 'Professor'),
       ('Jane', 'Actor'),
       ('Jenny', 'Doctor'),
       ('Priya', 'Singer');

Q80. Generate the following two result sets:

A) Query an alphabetically ordered list of all names in OCCUPATIONS, immediately followed by the first letter of each profession as a parenthetical (i.e.: enclosed in parentheses). 
   For example: AnActorName(A), ADoctorName(D), AProfessorName(P), and ASingerName(S).

SELECT CONCAT(name, ' ', '(', LEFT(occupation, 1), ')') AS name_plus_profession
FROM occupations
ORDER BY name;

B) Query the number of occurrences of each occupation in OCCUPATIONS. Sort the occurrences in ascending order, and output them in the following format: 
   There are a total of [occupation_count] [occupation]s, 
   where [occupation_count] is the number of occurrences of an occupation in OCCUPATIONS and [occupation] is the lowercase occupation name. 
   If more than one Occupation has the same [occupation_count], they should be ordered alphabetically.
   Note: There will be at least two entries in the table for each type of occupation.

SELECT CONCAT('There are a total of', ' ', occupation_count, ' ', occupation, 's') AS output
FROM
	(SELECT occupation, COUNT(name) AS occupation_count 
	FROM occupations
	GROUP BY occupation
	HAVING occupation_count >= 2
	ORDER BY occupation_count, occupation) tmp;
    
Q81. Pivot the Occupation column in OCCUPATIONS so that each Name is sorted alphabetically and displayed underneath its corresponding Occupation. The output column headers should be 		 Doctor, Professor, Singer, and Actor, respectively.
     Note: Print NULL when there are no more names corresponding to an occupation

SELECT Doctor, Professor, Singer,  Actor
FROM
	(SELECT name_order,
	MAX(CASE WHEN occupation = 'Doctor' THEN name END) AS 'Doctor',
	MAX(CASE WHEN occupation = 'Professor' THEN name END) AS 'Professor',
	MAX(CASE WHEN occupation = 'Singer' THEN name END) AS 'Singer',
	MAX(CASE WHEN occupation = 'Actor' THEN name END) AS 'Actor'
	FROM
		(SELECT occupation, name,
				ROW_NUMBER() OVER(PARTITION BY occupation ORDER BY name ASC) AS name_order
		FROM occupations) tmp
    GROUP BY name_order) tmp2;

# Question-82:
BST table

CREATE TABLE IF NOT EXISTS BST
(   N int,
    P int
);

INSERT INTO BST VALUES(1,2),(3,2),(6,8),(9,8),(2,5),(8,5),(5,null);

Q82. Write a query to find the node type of Binary Tree ordered by the value of the node. Output one of the following for each node:
	  Root: If node is root node.
	  Leaf: If node is leaf node.
      Inner: If node is neither root nor leaf node

SELECT N AS node,
CASE WHEN N NOT IN (SELECT DISTINCT(P) FROM bst WHERE P IS NOT NULL) THEN 'Leaf'
	 WHEN p IS NULL THEN 'Root'
     ELSE 'Inner'
END AS node_type
FROM bst;

# Question-83:
Company, Lead_manager, Senior_manager, Manager, Employee2 table

CREATE TABLE IF NOT EXISTS Company
(
    company_code VARCHAR(50),
    founder VARCHAR(50)
);

INSERT INTO Company VALUES ('C1','Monika'),('C2','Samantha');

CREATE TABLE IF NOT EXISTS Lead_Manager
(
    lead_manager_code VARCHAR(50),
    company_code VARCHAR(50)
);

INSERT INTO Lead_Manager VALUES ('LM1','C1'),('LM2','C2');

CREATE TABLE IF NOT EXISTS Senior_Manager
(
    senior_manager_code VARCHAR(50),
    lead_manager_code VARCHAR(50),
    company_code VARCHAR(50)
);

INSERT INTO Senior_Manager VALUES ('SM1','LM1','C1'),('SM2','LM1','C1'),('SM3','LM2','C2');

SELECT * FROM Senior_Manager;

CREATE TABLE IF NOT EXISTS Manager
(
    manager_code VARCHAR(50),
    senior_manager_code VARCHAR(50),
    lead_manager_code VARCHAR(50),
    company_code VARCHAR(50)
);

INSERT INTO Manager VALUES ('M1','SM1','LM1','C1'),('M2','SM3','LM2','C2'),('M3','SM3','LM2','C2');

CREATE TABLE IF NOT EXISTS Employee2
(
    employee_code VARCHAR(50),
    manager_code VARCHAR(50),
    senior_manager_code VARCHAR(50),
    lead_manager_code VARCHAR(50),
    company_code VARCHAR(50)
);

INSERT INTO Employee2 VALUES ('E1','M1','SM1','LM1','C1'),('E2','M1','SM1','LM1','C1'),('E3','M2','SM3','LM2','C2'),('E4','M3','SM3','LM2','C2');

Q83. Given the table schemas below, write a query to print the company_code, founder name, total number of lead managers, total number of senior managers, total number of managers, and 
     total number of employees. Order your output by ascending company_code.

SELECT c.company_code, c.founder, 
	   COUNT(DISTINCT(lm.lead_manager_code)) AS lead_mgr_count,
	   COUNT(DISTINCT(sm.senior_manager_code))  AS senior_mgr_count,
	   COUNT(DISTINCT(m.manager_code)) AS mgr_count,
	   COUNT(emp.employee_code) AS emp_count
FROM company c
INNER JOIN lead_manager lm
ON c.company_code = lm.company_code
INNER JOIN senior_manager sm
ON lm.lead_manager_code = sm.lead_manager_code
LEFT JOIN manager m
ON m.senior_manager_code = sm.senior_manager_code
LEFT JOIN employee2 emp
ON emp.manager_code = m.manager_code 
GROUP BY c.company_code, c.founder;

